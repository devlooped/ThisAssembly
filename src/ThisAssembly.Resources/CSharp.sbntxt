//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     ThisAssembly.Resources: {{ Version }}
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
{{ func resource }}
		/// <summary>
		{{~ if $0.Comment ~}}
		/// {{ $0.Comment }}
		{{~ else ~}}
		/// => @"{{ $0.Path }}"
		{{~ end ~}}
		/// </summary>
		public static partial class {{ $0.Name }}
		{
			#if DEBUG
			static readonly string baseDir = Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location) ?? "";
			#endif

			{{~ if $0.IsText ~}}
			private static string text;

            /// <summary>
            /// Gets the resource as plain text.
            /// </summary>
			public static string Text => text ??= GetContent(@"{{ $0.Path }}");
			{{~ end ~}}

            /// <summary>
            /// Gets the resource as a byte array.
            /// </summary>
			public static byte[] GetBytes() => GetBytes(@"{{ $0.Path }}");

            /// <summary>
            /// Gets the resource as a stream.
            /// </summary>
			public static Stream GetStream() => GetStream(@"{{ $0.Path }}");

			/// <summary>
			/// Gets the content of the embedded resource at the specified relative path.
			/// </summary>
 			static string GetContent(string relativePath)
 			{
 				using var stream = GetStream(relativePath);
 				using var reader = new StreamReader(stream);
 				return reader.ReadToEnd();
 			}
 			
 			/// <summary>
 			/// Gets the bytes of the embedded resource at the specified relative path.
 			/// </summary>
 			static byte[] GetBytes(string relativePath)
 			{
 				using var stream = GetStream(relativePath);
 				var bytes = new byte[stream.Length];
 				stream.Read(bytes, 0, bytes.Length);
 				return bytes;
 			}
 			
 			/// <summary>
 			/// Gets the stream of the embedded resource at the specified relative path.
 			/// </summary>
 			/// <exception cref="InvalidOperationException"></exception>
 			static Stream GetStream(string relativePath)
 			{
 				var baseName = Assembly.GetExecutingAssembly().GetName().Name;
 				var resourceName = relativePath
 					.TrimStart('.')
 					.Replace('/', '.')
 					.Replace('\\', '.');
 				
 				var manifestResourceName = Assembly.GetExecutingAssembly()
 					.GetManifestResourceNames().FirstOrDefault(x => x.EndsWith(resourceName, StringComparison.Ordinal));
 				
 				if (string.IsNullOrEmpty(manifestResourceName))
 					throw new InvalidOperationException($"Did not find required resource ending in '{resourceName}' in assembly '{baseName}'.");
 				
 				return
 					Assembly.GetExecutingAssembly().GetManifestResourceStream(manifestResourceName) ??
 					throw new InvalidOperationException($"Did not find required resource '{manifestResourceName}' in assembly '{baseName}'.");
 			}
		}
{{ end }}
{{ func render }}
    /// <summary>
    /// {{ $0.Comment }}
    /// </summary>
	public static partial class {{ $0.Name | string.replace "-" "_" | string.replace " " "_" }}
	{
		{{~ if $0.Resources ~}}
        {{~ for $r in $0.Resources ~}}
		{{- resource $r ~}}
        {{~ end ~}}
		{{~ else ~}}
		{{ render $0.NestedArea }}
		{{~ end ~}}
	}
{{ end }}

using System;
using System.IO;
using System.Linq;
using System.Reflection;
{{ if Namespace }}
namespace {{ Namespace }};
{{~ end ~}}

/// <summary>
/// Provides access to the current assembly information.
/// </summary>
{{ Visibility }}partial class ThisAssembly
{
	{{ render RootArea }}
}
