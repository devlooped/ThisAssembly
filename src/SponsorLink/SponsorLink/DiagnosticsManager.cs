// <autogenerated />
#nullable enable
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.IO.MemoryMappedFiles;
using System.Linq;
using System.Threading;
using Humanizer;
using Humanizer.Localisation;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Diagnostics;
using static Devlooped.Sponsors.SponsorLink;

namespace Devlooped.Sponsors;

/// <summary>
/// Manages diagnostics for the SponsorLink analyzer so that there are no duplicates 
/// when multiple projects share the same product name (i.e. ThisAssembly).
/// </summary>
class DiagnosticsManager
{
    static readonly Guid appDomainDiagnosticsKey = new(0x8d0e2670, 0xe6c4, 0x45c8, 0x81, 0xba, 0x5a, 0x36, 0x81, 0xd3, 0x65, 0x3e);

    public static Dictionary<SponsorStatus, DiagnosticDescriptor> KnownDescriptors { get; } = new()
    {
        // Requires:
        // <Constant Include="Funding.Product" Value="[PRODUCT_NAME]" />
        // <Constant Include="Funding.AnalyzerPrefix" Value="[PREFIX]" />
        { SponsorStatus.Unknown, CreateUnknown([.. Sponsorables.Keys], Funding.Product, Funding.Prefix) },
        { SponsorStatus.Sponsor, CreateSponsor([.. Sponsorables.Keys], Funding.Prefix) },
        { SponsorStatus.Expiring, CreateExpiring([.. Sponsorables.Keys], Funding.Prefix) },
        { SponsorStatus.Expired,  CreateExpired([.. Sponsorables.Keys], Funding.Prefix) },
    };

    /// <summary>
    /// Acceses the diagnostics dictionary for the current <see cref="AppDomain"/>.
    /// </summary>
    ConcurrentDictionary<string, Diagnostic> Diagnostics
        => AppDomainDictionary.Get<ConcurrentDictionary<string, Diagnostic>>(appDomainDiagnosticsKey.ToString());

    /// <summary>
    /// Attemps to remove a diagnostic for the given product.
    /// </summary>
    /// <param name="product">The product diagnostic that might have been pushed previously.</param>
    /// <returns>The removed diagnostic, or <see langword="null" /> if none was previously pushed.</returns>
    public void ReportOnce(Action<Diagnostic> report, string product = Funding.Product)
    {
        if (Diagnostics.TryRemove(product, out var diagnostic))
        {
            // Ensure only one such diagnostic is reported per product for the entire process, 
            // so that we can avoid polluting the error list with duplicates across multiple projects.
            var id = string.Concat(Process.GetCurrentProcess().Id, product, diagnostic.Id);
            using var mutex = new Mutex(false, "mutex" + id);
            mutex.WaitOne();
            using var mmf = MemoryMappedFile.CreateOrOpen(id, 1);
            using var accessor = mmf.CreateViewAccessor();
            if (accessor.ReadByte(0) == 0)
            {
                accessor.Write(0, 1);
                report(diagnostic);
                Tracing.Trace($"👈{diagnostic.Severity.ToString().ToLowerInvariant()}:{Process.GetCurrentProcess().Id}:{Process.GetCurrentProcess().ProcessName}:{product}:{diagnostic.Id}");
            }
        }
    }

    /// <summary>
    /// Gets the status of the given product based on a previously stored diagnostic. 
    /// To ensure the value is always set before returning, use <see cref="GetOrSetStatus"/>.
    /// This method is safe to use (and would get a non-null value) in analyzers that run after CompilationStartAction(see 
    /// https://github.com/dotnet/roslyn/blob/main/docs/analyzers/Analyzer%20Actions%20Semantics.md under Ordering of actions).
    /// </summary>
    /// <returns>Optional <see cref="SponsorStatus"/> that was reported, if any.</returns>
    public SponsorStatus? GetStatus()
    {
        // NOTE: the SponsorLinkAnalyzer.SetStatus uses diagnostic properties to store the 
        // kind of diagnostic as a simple string instead of the enum. We do this so that 
        // multiple analyzers or versions even across multiple products, which all would 
        // have their own enum, can still share the same diagnostic kind.
        if (Diagnostics.TryGetValue(Funding.Product, out var diagnostic) &&
            diagnostic.Properties.TryGetValue(nameof(SponsorStatus), out var value))
        {
            // Switch on value matching DiagnosticKind names
            return value switch
            {
                nameof(SponsorStatus.Unknown) => SponsorStatus.Unknown,
                nameof(SponsorStatus.Sponsor) => SponsorStatus.Sponsor,
                nameof(SponsorStatus.Expiring) => SponsorStatus.Expiring,
                nameof(SponsorStatus.Expired) => SponsorStatus.Expired,
                _ => null,
            };
        }

        return null;
    }

    /// <summary>
    /// Gets the status of the <see cref="Funding.Product"/>, or sets it from 
    /// the given set of <paramref name="manifests"/> if not already set.
    /// </summary>
    public SponsorStatus GetOrSetStatus(ImmutableArray<AdditionalText> manifests)
        => GetOrSetStatus(() => manifests);

    /// <summary>
    /// Gets the status of the <see cref="Funding.Product"/>, or sets it from 
    /// the given analyzer <paramref name="options"/> if not already set.
    /// </summary>
    public SponsorStatus GetOrSetStatus(Func<AnalyzerOptions?> options)
        => GetOrSetStatus(() => options().GetSponsorManifests());

    SponsorStatus GetOrSetStatus(Func<ImmutableArray<AdditionalText>> getManifests)
    {
        if (GetStatus() is { } status)
            return status;

        if (!SponsorLink.TryRead(out var claims, getManifests().Select(text =>
                (text.GetText()?.ToString() ?? "", Sponsorables[Path.GetFileNameWithoutExtension(text.Path)]))) ||
            claims.GetExpiration() is not DateTime exp)
        {
            // report unknown, either unparsed manifest or one with no expiration (which we never emit).
            Push(Diagnostic.Create(KnownDescriptors[SponsorStatus.Unknown], null,
                properties: ImmutableDictionary.Create<string, string?>().Add(nameof(SponsorStatus), nameof(SponsorStatus.Unknown)),
                Funding.Product, Sponsorables.Keys.Humanize(Resources.Or)));
            return SponsorStatus.Unknown;
        }
        else if (exp < DateTime.Now)
        {
            // report expired or expiring soon if still within the configured days of grace period
            if (exp.AddDays(Funding.Grace) < DateTime.Now)
            {
                // report expiring soon
                Push(Diagnostic.Create(KnownDescriptors[SponsorStatus.Expiring], null,
                    properties: ImmutableDictionary.Create<string, string?>().Add(nameof(SponsorStatus), nameof(SponsorStatus.Expiring))));
                return SponsorStatus.Expiring;
            }
            else
            {
                // report expired
                Push(Diagnostic.Create(KnownDescriptors[SponsorStatus.Expired], null,
                    properties: ImmutableDictionary.Create<string, string?>().Add(nameof(SponsorStatus), nameof(SponsorStatus.Expired))));
                return SponsorStatus.Expired;
            }
        }
        else
        {
            // report sponsor
            Push(Diagnostic.Create(KnownDescriptors[SponsorStatus.Sponsor], null,
                properties: ImmutableDictionary.Create<string, string?>().Add(nameof(SponsorStatus), nameof(SponsorStatus.Sponsor)),
                Funding.Product));
            return SponsorStatus.Sponsor;
        }
    }

    /// <summary>
    /// Pushes a diagnostic for the given product. 
    /// </summary>
    /// <returns>The same diagnostic that was pushed, for chained invocations.</returns>
    Diagnostic Push(Diagnostic diagnostic, string product = Funding.Product)
    {
        // We only expect to get one warning per sponsorable+product 
        // combination, and first one to set wins.
        if (Diagnostics.TryAdd(product, diagnostic))
        {
            // Reset the process-wide flag for this diagnostic.
            var id = string.Concat(Process.GetCurrentProcess().Id, product, diagnostic.Id);
            using var mutex = new Mutex(false, "mutex" + id);
            mutex.WaitOne();
            using var mmf = MemoryMappedFile.CreateOrOpen(id, 1);
            using var accessor = mmf.CreateViewAccessor();
            accessor.Write(0, 0);
            Tracing.Trace($"👉{diagnostic.Severity.ToString().ToLowerInvariant()}:{Process.GetCurrentProcess().Id}:{Process.GetCurrentProcess().ProcessName}:{product}:{diagnostic.Id}");
        }

        return diagnostic;
    }

    internal static DiagnosticDescriptor CreateSponsor(string[] sponsorable, string prefix) => new(
        $"{prefix}100",
        Resources.Sponsor_Title,
        Resources.Sponsor_Message,
        "SponsorLink",
        DiagnosticSeverity.Info,
        isEnabledByDefault: true,
        description: Resources.Sponsor_Description,
        helpLinkUri: "https://github.com/devlooped#sponsorlink",
        "DoesNotSupportF1Help");

    internal static DiagnosticDescriptor CreateUnknown(string[] sponsorable, string product, string prefix) => new(
        $"{prefix}101",
        Resources.Unknown_Title,
        Resources.Unknown_Message,
        "SponsorLink",
        DiagnosticSeverity.Warning,
        isEnabledByDefault: true,
        description: string.Format(CultureInfo.CurrentCulture, Resources.Unknown_Description,
            sponsorable.Humanize(x => $"https://github.com/sponsors/{x}"),
            string.Join(" ", sponsorable)),
        helpLinkUri: "https://github.com/devlooped#sponsorlink",
        WellKnownDiagnosticTags.NotConfigurable);

    internal static DiagnosticDescriptor CreateExpiring(string[] sponsorable, string prefix) => new(
         $"{prefix}103",
         Resources.Expiring_Title,
         Resources.Expiring_Message,
         "SponsorLink",
         DiagnosticSeverity.Warning,
         isEnabledByDefault: true,
         description: string.Format(CultureInfo.CurrentCulture, Resources.Expiring_Description, string.Join(" ", sponsorable)),
         helpLinkUri: "https://github.com/devlooped#autosync",
         "DoesNotSupportF1Help", WellKnownDiagnosticTags.NotConfigurable);

    internal static DiagnosticDescriptor CreateExpired(string[] sponsorable, string prefix) => new(
         $"{prefix}104",
         Resources.Expired_Title,
         Resources.Expired_Message,
         "SponsorLink",
         DiagnosticSeverity.Warning,
         isEnabledByDefault: true,
         description: string.Format(CultureInfo.CurrentCulture, Resources.Expired_Description, string.Join(" ", sponsorable)),
         helpLinkUri: "https://github.com/devlooped#autosync",
         "DoesNotSupportF1Help", WellKnownDiagnosticTags.NotConfigurable);
}
