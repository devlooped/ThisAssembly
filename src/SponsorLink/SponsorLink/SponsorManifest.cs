// <autogenerated />
#nullable enable
using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.IO;
using System.Security.Claims;
using Microsoft.IdentityModel.JsonWebTokens;
using Microsoft.IdentityModel.Tokens;

namespace Devlooped.Sponsors;

/// <summary>
/// The resulting status from validation.
/// </summary>
public enum ManifestStatus
{
    /// <summary>
    /// The manifest couldn't be read at all.
    /// </summary>
    Unknown,
    /// <summary>
    /// The manifest was read and is valid (not expired and properly signed).
    /// </summary>
    Valid,
    /// <summary>
    /// The manifest was read but has expired.
    /// </summary>
    Expired,
    /// <summary>
    /// The manifest was read, but its signature is invalid.
    /// </summary>
    Invalid,
}

/// <summary>
/// Represents the sponsorship status of a user.
/// </summary>
/// <param name="Status">The status.</param>
/// <param name="Principal">The principal potentially containing roles validated from the manifest.</param>
/// <param name="SecurityToken">The security token from the validated manifest.</param>
public record SponsorManifest(ManifestStatus Status, ClaimsPrincipal Principal, SecurityToken? SecurityToken)
{
    /// <summary>
    /// Whether the manifest <see cref="Status"/> is <see cref="ManifestStatus.Valid"/>.
    /// </summary>
    public bool IsValid => Status == ManifestStatus.Valid;
}

static partial class SponsorLink
{
    /// <summary>
    /// Reads the local manifest (if present) for the specified sponsorable account and validates it 
    /// against the given JWK key.
    /// </summary>
    /// <param name="sponsorable">The sponsorable account to read.</param>
    /// <param name="jwk">The public key to validate the signature on the manifest JWT if found.</param>
    /// <param name="validateExpiration">Whether to validate the manifest expiration. If <see langword="false"/>, 
    /// an expired manifest will be reported as <see cref="ManifestStatus.Valid"/>. The expiration date 
    /// can be checked in that case via the <see cref="SponsorManifest.SecurityToken"/>.</param>
    /// <returns>A manifest that represents the user status.</returns>
    public static SponsorManifest GetManifest(string sponsorable, string jwk, bool validateExpiration = true)
    {
        var path = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.UserProfile), 
            ".sponsorlink", "github", sponsorable + ".jwt");

        if (!File.Exists(path))
            return new SponsorManifest(ManifestStatus.Unknown, new ClaimsPrincipal(), null);

        return ParseManifest(File.ReadAllText(path), jwk, validateExpiration);
    }

    internal static SponsorManifest ParseManifest(string jwt, string jwk, bool validateExpiration)
    {
        var status = Validate(jwt, jwk, out var token, out var identity, validateExpiration);

        if (status == ManifestStatus.Unknown || identity == null)
            return new SponsorManifest(status, new ClaimsPrincipal(), token);

        return new SponsorManifest(status, new JwtRolesPrincipal(identity), token);
    }

    /// <summary>
    /// Validates the manifest signature and optional expiration.
    /// </summary>
    /// <param name="jwt">The JWT to validate.</param>
    /// <param name="jwk">The key to validate the manifest signature with.</param>
    /// <param name="token">Except when returning <see cref="Status.Unknown"/>, returns the security token read from the JWT, even if signature check failed.</param>
    /// <param name="identity">The associated claims, only when return value is not <see cref="Status.Unknown"/>.</param>
    /// <param name="requireExpiration">Whether to check for expiration.</param>
    /// <returns>The status of the validation.</returns>
    public static ManifestStatus Validate(string jwt, string jwk, out SecurityToken? token, out ClaimsIdentity? identity, bool validateExpiration)
    {
        token = default;
        identity = default;

        SecurityKey key;
        try
        {
            key = JsonWebKey.Create(jwk);
        }
        catch (ArgumentException)
        {
            return ManifestStatus.Unknown;
        }

        var handler = new JsonWebTokenHandler { MapInboundClaims = false };

        if (!handler.CanReadToken(jwt))
            return ManifestStatus.Unknown;

        var validation = new TokenValidationParameters
        {
            RequireExpirationTime = false,
            ValidateLifetime = false,
            ValidateAudience = false,
            ValidateIssuer = false,
            ValidateIssuerSigningKey = true,
            IssuerSigningKey = key,
            RoleClaimType = "roles",
            NameClaimType = "sub",
        };

        var result = handler.ValidateTokenAsync(jwt, validation).Result;
        if (!result.IsValid || result.Exception != null)
        {
            if (result.Exception is SecurityTokenInvalidSignatureException)
            {
                var jwtToken = handler.ReadJsonWebToken(jwt);
                token = jwtToken;
                identity = new ClaimsIdentity(jwtToken.Claims);
                return ManifestStatus.Invalid;
            }
            else
            {
                var jwtToken = handler.ReadJsonWebToken(jwt);
                token = jwtToken;
                identity = new ClaimsIdentity(jwtToken.Claims);
                return ManifestStatus.Invalid;
            }
        }

        token = result.SecurityToken;
        identity = new ClaimsIdentity(result.ClaimsIdentity.Claims, "JWT");

        if (validateExpiration && token.ValidTo == DateTime.MinValue)
            return ManifestStatus.Invalid;

        // The sponsorable manifest does not have an expiration time.
        if (validateExpiration && token.ValidTo < DateTimeOffset.UtcNow)
            return ManifestStatus.Expired;

        return ManifestStatus.Valid;
    }

    class JwtRolesPrincipal(ClaimsIdentity identity) : ClaimsPrincipal([identity])
    {
        public override bool IsInRole(string role) => HasClaim("roles", role) || base.IsInRole(role);
    }
}
