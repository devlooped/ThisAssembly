// <autogenerated />
#nullable enable
using System;
using System.Collections.Immutable;
using System.IO;
using System.Linq;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Diagnostics;
using static Devlooped.Sponsors.SponsorLink;

namespace Devlooped.Sponsors;

/// <summary>
/// Links the sponsor status for the current compilation.
/// </summary>
[DiagnosticAnalyzer(LanguageNames.CSharp, LanguageNames.VisualBasic)]
public class SponsorLinkAnalyzer : DiagnosticAnalyzer
{
    public override ImmutableArray<DiagnosticDescriptor> SupportedDiagnostics { get; } = DiagnosticsManager.KnownDescriptors.Values.ToImmutableArray();

#pragma warning disable RS1026 // Enable concurrent execution
    public override void Initialize(AnalysisContext context)
#pragma warning restore RS1026 // Enable concurrent execution
    {
#if !DEBUG
        // Only enable concurrent execution in release builds, otherwise debugging is quite annoying.
        context.EnableConcurrentExecution();
#endif
        context.ConfigureGeneratedCodeAnalysis(GeneratedCodeAnalysisFlags.None);

#pragma warning disable RS1013 // Start action has no registered non-end actions
        // We do this so that the status is set at compilation start so we can use it 
        // across all other analyzers. We report only on finish because multiple 
        // analyzers can report the same diagnostic and we want to avoid duplicates. 
        context.RegisterCompilationStartAction(ctx =>
        {
            // Setting the status early allows other analyzers to potentially check for it.
            var status = Diagnostics.GetOrSetStatus(() => ctx.Options);

            // Never report any diagnostic unless we're in an editor.
            if (IsEditor)
            {
                ctx.RegisterCompilationEndAction(ctx =>
                {
                    // NOTE: for multiple projects with the same product name, we only report one diagnostic, 
                    // so it's expected to NOT get a diagnostic back. Also, we don't want to report 
                    // multiple diagnostics for each project in a solution that uses the same product.
                    Diagnostics.ReportOnce(diagnostic =>
                    {
                        // For unknown (never sync'ed), only report if install grace period is over
                        if (status == SponsorStatus.Unknown)
                        {
                            var noGrace = ctx.Options.AnalyzerConfigOptionsProvider.GlobalOptions.TryGetValue("build_property.SponsorLinkNoInstallGrace", out var value) &&
                                           bool.TryParse(value, out var skipCheck) && skipCheck;

                            // NOTE: we'll always report if noGrace is set to true, regardless of install time, for 
                            // testing purposes. This can be achieved via MSBuild with:
                            // <PropertyGroup>
                            //   <SponsorLinkNoInstallGrace>true</SponsorLinkNoInstallGrace>
                            // </PropertyGroup>
                            // <ItemGroup>
                            //   <CompilerVisibleProperty Include="SponsorLinkNoInstallGrace" />
                            // </ItemGroup>
                            if (noGrace == false)
                            {
                                var installed = ctx.Options.AdditionalFiles.Where(x =>
                                {
                                    var options = ctx.Options.AnalyzerConfigOptionsProvider.GetOptions(x);
                                    // In release builds, we'll have a single such item, since we IL-merge the analyzer.
                                    return options.TryGetValue("build_metadata.Analyzer.ItemType", out var itemType) &&
                                           options.TryGetValue("build_metadata.Analyzer.NuGetPackageId", out var packageId) &&
                                           itemType == "Analyzer" &&
                                           packageId == Funding.Product;
                                }).Select(x => File.GetLastWriteTime(x.Path)).OrderByDescending(x => x).FirstOrDefault();

                                // NOTE: if we can't determine install time, we'll always report.
                                if (installed != default && installed.AddDays(Funding.Grace) > DateTime.Now)
                                    return;
                            }
                        }

                        ctx.ReportDiagnostic(diagnostic);
                    });
                });
            }
        });
#pragma warning restore RS1013 // Start action has no registered non-end actions
    }
}
