// <autogenerated />
#nullable enable
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Diagnostics;
using System.IO;
using System.Linq;
using Humanizer;
using Humanizer.Localisation;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Diagnostics;
using static Devlooped.Sponsors.SponsorLink;

namespace Devlooped.Sponsors;

/// <summary>
/// Links the sponsor status for the current compilation.
/// </summary>
[DiagnosticAnalyzer(LanguageNames.CSharp, LanguageNames.VisualBasic)]
public class SponsorLinkAnalyzer : DiagnosticAnalyzer
{
    static readonly Dictionary<SponsorStatus, DiagnosticDescriptor> descriptors = new()
    {
        // Requires:
        // <Constant Include="Funding.Product" Value="[PRODUCT_NAME]" />
        // <Constant Include="Funding.AnalyzerPrefix" Value="[PREFIX]" />
        { SponsorStatus.Unknown, Diagnostics.GetDescriptor([.. Sponsorables.Keys], Funding.Product, Funding.Prefix, SponsorStatus.Unknown) },
        { SponsorStatus.Sponsor, Diagnostics.GetDescriptor([.. Sponsorables.Keys], Funding.Product, Funding.Prefix, SponsorStatus.Sponsor) },
        { SponsorStatus.Expiring, Diagnostics.GetDescriptor([.. Sponsorables.Keys], Funding.Product, Funding.Prefix, SponsorStatus.Expiring) },
        { SponsorStatus.Expired, Diagnostics.GetDescriptor([.. Sponsorables.Keys], Funding.Product, Funding.Prefix, SponsorStatus.Expired) },
    };

    public override ImmutableArray<DiagnosticDescriptor> SupportedDiagnostics { get; } = descriptors.Values.ToImmutableArray();

#pragma warning disable RS1026 // Enable concurrent execution
    public override void Initialize(AnalysisContext context)
#pragma warning restore RS1026 // Enable concurrent execution
    {
#if !DEBUG
        // Only enable concurrent execution in release builds, otherwise debugging is quite annoying.
        context.EnableConcurrentExecution();
#endif
        context.ConfigureGeneratedCodeAnalysis(GeneratedCodeAnalysisFlags.None);

#pragma warning disable RS1013 // Start action has no registered non-end actions
        // We do this so that the status is set at compilation start so we can use it 
        // across all other analyzers. We report only on finish because multiple 
        // analyzers can report the same diagnostic and we want to avoid duplicates. 
        context.RegisterCompilationStartAction(ctx =>
        {
            var manifests = ctx.Options.AdditionalFiles
                .Where(x =>
                    ctx.Options.AnalyzerConfigOptionsProvider.GetOptions(x).TryGetValue("build_metadata.SponsorManifest.ItemType", out var itemType) &&
                    itemType == "SponsorManifest" &&
                    Sponsorables.ContainsKey(Path.GetFileNameWithoutExtension(x.Path)))
                .ToImmutableArray();

            // Setting the status early allows other analyzers to potentially check for it.
            var status = SetStatus(manifests);

            // Never report any diagnostic unless we're in an editor.
            if (IsEditor)
            {
                ctx.RegisterCompilationEndAction(ctx =>
                {
                    // NOTE: for multiple projects with the same product name, we only report one diagnostic, 
                    // so it's expected to NOT get a diagnostic back. Also, we don't want to report 
                    // multiple diagnostics for each project in a solution that uses the same product.
                    if (Diagnostics.Pop(Funding.Product) is Diagnostic diagnostic)
                    {
                        // For unknown (never sync'ed), only report if install grace period is over
                        if (status == SponsorStatus.Unknown)
                        {
                            var noGrace = ctx.Options.AnalyzerConfigOptionsProvider.GlobalOptions.TryGetValue("build_property.SponsorLinkNoInstallGrace", out var value) &&
                                           bool.TryParse(value, out var skipCheck) && skipCheck;

                            // NOTE: we'll always report if noGrace is set to true, regardless of install time, for 
                            // testing purposes. This can be achieved via MSBuild with:
                            // <PropertyGroup>
                            //   <SponsorLinkNoInstallGrace>true</SponsorLinkNoInstallGrace>
                            // </PropertyGroup>
                            // <ItemGroup>
                            //   <CompilerVisibleProperty Include="SponsorLinkNoInstallGrace" />
                            // </ItemGroup>
                            if (noGrace == false)
                            {
                                var installed = ctx.Options.AdditionalFiles.Where(x =>
                                {
                                    var options = ctx.Options.AnalyzerConfigOptionsProvider.GetOptions(x);
                                    // In release builds, we'll have a single such item, since we IL-merge the analyzer.
                                    return options.TryGetValue("build_metadata.Analyzer.ItemType", out var itemType) &&
                                           options.TryGetValue("build_metadata.Analyzer.NuGetPackageId", out var packageId) &&
                                           itemType == "Analyzer" &&
                                           packageId == Funding.Product;
                                }).Select(x => File.GetLastWriteTime(x.Path)).OrderByDescending(x => x).FirstOrDefault();

                                // NOTE: if we can't determine install time, we'll always report.
                                if (installed != default && installed.AddDays(Funding.Grace) > DateTime.Now)
                                    return;
                            }
                        }

                        ctx.ReportDiagnostic(diagnostic);
                    }
                });
            }
        });
#pragma warning restore RS1013 // Start action has no registered non-end actions
    }

    SponsorStatus SetStatus(ImmutableArray<AdditionalText> manifests)
    {
        if (!SponsorLink.TryRead(out var claims, manifests.Select(text =>
                (text.GetText()?.ToString() ?? "", Sponsorables[Path.GetFileNameWithoutExtension(text.Path)]))) ||
            claims.GetExpiration() is not DateTime exp)
        {
            // report unknown, either unparsed manifest or one with no expiration (which we never emit).
            Diagnostics.Push(Funding.Product, Diagnostic.Create(descriptors[SponsorStatus.Unknown], null,
                properties: ImmutableDictionary.Create<string, string?>().Add(nameof(SponsorStatus), nameof(SponsorStatus.Unknown)),
                Funding.Product, Sponsorables.Keys.Humanize(Resources.Or)));
            return SponsorStatus.Unknown;
        }
        else if (exp < DateTime.Now)
        {
            // report expired or expiring soon if still within the configured days of grace period
            if (exp.AddDays(Funding.Grace) < DateTime.Now)
            {
                // report expiring soon
                Diagnostics.Push(Funding.Product, Diagnostic.Create(descriptors[SponsorStatus.Expiring], null,
                    properties: ImmutableDictionary.Create<string, string?>().Add(nameof(SponsorStatus), nameof(SponsorStatus.Expiring))));
                return SponsorStatus.Expiring;
            }
            else
            {
                // report expired
                Diagnostics.Push(Funding.Product, Diagnostic.Create(descriptors[SponsorStatus.Expired], null,
                    properties: ImmutableDictionary.Create<string, string?>().Add(nameof(SponsorStatus), nameof(SponsorStatus.Expired))));
                return SponsorStatus.Expired;
            }
        }
        else
        {
            // report sponsor
            Diagnostics.Push(Funding.Product, Diagnostic.Create(descriptors[SponsorStatus.Sponsor], null,
                properties: ImmutableDictionary.Create<string, string?>().Add(nameof(SponsorStatus), nameof(SponsorStatus.Sponsor)),
                Funding.Product));
            return SponsorStatus.Sponsor;
        }
    }
}
